'SCons.Util\n\nVarious utility functions go here.\n'
__revision__ = 'src/engine/SCons/Util.py 5023 2010/06/14 22:05:46 scons'
import os
import sys
import copy
import re
import types
from collections import UserDict, UserList, UserString
InstanceType = types.InstanceType
MethodType = types.MethodType
FunctionType = types.FunctionType
try:
    unicode
except NameError:
    UnicodeType = None
else:
    UnicodeType = unicode
_altsep = os.altsep
if ((_altsep is None) and (sys.platform == 'win32')):
    _altsep = '/'
if _altsep:

    def rightmost_separator(path, sep):
        return max(path.rfind(sep), path.rfind(_altsep))
else:

    def rightmost_separator(path, sep):
        return path.rfind(sep)
_get_env_var = re.compile('^\\$([_a-zA-Z]\\w*|{[_a-zA-Z]\\w*})$')
IDX = (lambda N: ((N and 1) or 0))
DictTypes = (dict, UserDict)
ListTypes = (list, UserList)
SequenceTypes = (list, tuple, UserList)
StringTypes = (str, unicode, UserString)
BaseStringTypes = (str, unicode)
_semi_deepcopy_dispatch = d = {}
d[dict] = _semi_deepcopy_dict
d[list] = _semi_deepcopy_list
d[tuple] = _semi_deepcopy_tuple
d[InstanceType] = _semi_deepcopy_inst
can_read_reg = 0
try:
    import winreg
    can_read_reg = 1
    hkey_mod = winreg
    RegOpenKeyEx = winreg.OpenKeyEx
    RegEnumKey = winreg.EnumKey
    RegEnumValue = winreg.EnumValue
    RegQueryValueEx = winreg.QueryValueEx
    RegError = winreg.error
except ImportError:
    try:
        import win32api
        import win32con
        can_read_reg = 1
        hkey_mod = win32con
        RegOpenKeyEx = win32api.RegOpenKeyEx
        RegEnumKey = win32api.RegEnumKey
        RegEnumValue = win32api.RegEnumValue
        RegQueryValueEx = win32api.RegQueryValueEx
        RegError = win32api.error
    except ImportError:


        class _NoError(Exception):
            pass
        RegError = _NoError
if can_read_reg:
    HKEY_CLASSES_ROOT = hkey_mod.HKEY_CLASSES_ROOT
    HKEY_LOCAL_MACHINE = hkey_mod.HKEY_LOCAL_MACHINE
    HKEY_CURRENT_USER = hkey_mod.HKEY_CURRENT_USER
    HKEY_USERS = hkey_mod.HKEY_USERS

    def RegGetValue(root, key):
        "This utility function returns a value in the registry\n        without having to open the key first.  Only available on\n        Windows platforms with a version of Python that can read the\n        registry.  Returns the same thing as\n        SCons.Util.RegQueryValueEx, except you just specify the entire\n        path to the value, and don't have to bother opening the key\n        first.  So:\n\n        Instead of:\n          k = SCons.Util.RegOpenKeyEx(SCons.Util.HKEY_LOCAL_MACHINE,\n                r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion')\n          out = SCons.Util.RegQueryValueEx(k,\n                'ProgramFilesDir')\n\n        You can write:\n          out = SCons.Util.RegGetValue(SCons.Util.HKEY_LOCAL_MACHINE,\n                r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProgramFilesDir')\n        "
        p = (key.rfind('\\') + 1)
        keyp = key[:(p - 1)]
        val = key[p:]
        k = RegOpenKeyEx(root, keyp)
        return RegQueryValueEx(k, val)
else:
    try:
        e = WindowsError
    except NameError:


        class WindowsError(OSError):
            pass
        import builtins
        builtins.WindowsError = WindowsError
    else:
        del e
    HKEY_CLASSES_ROOT = None
    HKEY_LOCAL_MACHINE = None
    HKEY_CURRENT_USER = None
    HKEY_USERS = None

    def RegGetValue(root, key):
        raise WindowsError

    def RegOpenKeyEx(root, key):
        raise WindowsError
if (sys.platform == 'win32'):

    def WhereIs(file, path=None, pathext=None, reject=[]):
        if (path is None):
            try:
                path = os.environ['PATH']
            except KeyError:
                return None
        if is_String(path):
            path = path.split(os.pathsep)
        if (pathext is None):
            try:
                pathext = os.environ['PATHEXT']
            except KeyError:
                pathext = '.COM;.EXE;.BAT;.CMD'
        if is_String(pathext):
            pathext = pathext.split(os.pathsep)
        for ext in pathext:
            if (ext.lower() == file[(- len(ext)):].lower()):
                pathext = ['']
                break
        if ((not is_List(reject)) and (not is_Tuple(reject))):
            reject = [reject]
        for dir in path:
            f = os.path.join(dir, file)
            for ext in pathext:
                fext = (f + ext)
                if os.path.isfile(fext):
                    try:
                        reject.index(fext)
                    except ValueError:
                        return os.path.normpath(fext)
                    continue
        return None
elif (os.name == 'os2'):

    def WhereIs(file, path=None, pathext=None, reject=[]):
        if (path is None):
            try:
                path = os.environ['PATH']
            except KeyError:
                return None
        if is_String(path):
            path = path.split(os.pathsep)
        if (pathext is None):
            pathext = ['.exe', '.cmd']
        for ext in pathext:
            if (ext.lower() == file[(- len(ext)):].lower()):
                pathext = ['']
                break
        if ((not is_List(reject)) and (not is_Tuple(reject))):
            reject = [reject]
        for dir in path:
            f = os.path.join(dir, file)
            for ext in pathext:
                fext = (f + ext)
                if os.path.isfile(fext):
                    try:
                        reject.index(fext)
                    except ValueError:
                        return os.path.normpath(fext)
                    continue
        return None
else:

    def WhereIs(file, path=None, pathext=None, reject=[]):
        import stat
        if (path is None):
            try:
                path = os.environ['PATH']
            except KeyError:
                return None
        if is_String(path):
            path = path.split(os.pathsep)
        if ((not is_List(reject)) and (not is_Tuple(reject))):
            reject = [reject]
        for d in path:
            f = os.path.join(d, file)
            if os.path.isfile(f):
                try:
                    st = os.stat(f)
                except OSError:
                    continue
                if (stat.S_IMODE(st[stat.ST_MODE]) & 73):
                    try:
                        reject.index(f)
                    except ValueError:
                        return os.path.normpath(f)
                    continue
        return None
if (sys.platform == 'cygwin'):

    def get_native_path(path):
        'Transforms an absolute path into a native path for the system.  In\n        Cygwin, this converts from a Cygwin path to a Windows one.'
        return os.popen(('cygpath -w ' + path)).read().replace('\n', '')
else:

    def get_native_path(path):
        'Transforms an absolute path into a native path for the system.\n        Non-Cygwin version, just leave the path alone.'
        return path
display = DisplayEngine()
if (sys.platform == 'cygwin'):

    def case_sensitive_suffixes(s1, s2):
        return 0
else:

    def case_sensitive_suffixes(s1, s2):
        return (os.path.normcase(s1) != os.path.normcase(s2))
md5 = False
try:
    import hashlib
except ImportError:
    pass
else:
    if hasattr(hashlib, 'md5'):
        md5 = True

        def MD5signature(s):
            m = hashlib.md5()
            m.update(str(s))
            return m.hexdigest()

        def MD5filesignature(fname, chunksize=65536):
            m = hashlib.md5()
            f = open(fname, 'rb')
            while True:
                blck = f.read(chunksize)
                if (not blck):
                    break
                m.update(str(blck))
            f.close()
            return m.hexdigest()
del __revision__
