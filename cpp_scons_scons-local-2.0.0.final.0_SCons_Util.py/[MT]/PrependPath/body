def PrependPath(oldpath, newpath, sep=os.pathsep, delete_existing=1, canonicalize=None):
    'This prepends newpath elements to the given oldpath.  Will only\n    add any particular path once (leaving the first one it encounters\n    and ignoring the rest, to preserve path order), and will\n    os.path.normpath and os.path.normcase all paths to help assure\n    this.  This can also handle the case where the given old path\n    variable is a list instead of a string, in which case a list will\n    be returned instead of a string.\n\n    Example:\n      Old Path: "/foo/bar:/foo"\n      New Path: "/biz/boom:/foo"\n      Result:   "/biz/boom:/foo:/foo/bar"\n\n    If delete_existing is 0, then adding a path that exists will\n    not move it to the beginning; it will stay where it is in the\n    list.\n\n    If canonicalize is not None, it is applied to each element of \n    newpath before use.\n    '
    orig = oldpath
    is_list = 1
    paths = orig
    if ((not is_List(orig)) and (not is_Tuple(orig))):
        paths = paths.split(sep)
        is_list = 0
    if is_String(newpath):
        newpaths = newpath.split(sep)
    elif ((not is_List(newpath)) and (not is_Tuple(newpath))):
        newpaths = [newpath]
    else:
        newpaths = newpath
    if canonicalize:
        newpaths = list(map(canonicalize, newpaths))
    if (not delete_existing):
        result = []
        normpaths = []
        for path in paths:
            if (not path):
                continue
            normpath = os.path.normpath(os.path.normcase(path))
            if (normpath not in normpaths):
                result.append(path)
                normpaths.append(normpath)
        newpaths.reverse()
        for path in newpaths:
            if (not path):
                continue
            normpath = os.path.normpath(os.path.normcase(path))
            if (normpath not in normpaths):
                result.insert(0, path)
                normpaths.append(normpath)
        paths = result
    else:
        newpaths = (newpaths + paths)
        normpaths = []
        paths = []
        for path in newpaths:
            normpath = os.path.normpath(os.path.normcase(path))
            if (path and (not (normpath in normpaths))):
                paths.append(path)
                normpaths.append(normpath)
    if is_list:
        return paths
    else:
        return sep.join(paths)
