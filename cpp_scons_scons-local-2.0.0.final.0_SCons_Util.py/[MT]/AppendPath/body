def AppendPath(oldpath, newpath, sep=os.pathsep, delete_existing=1, canonicalize=None):
    'This appends new path elements to the given old path.  Will\n    only add any particular path once (leaving the last one it\n    encounters and ignoring the rest, to preserve path order), and\n    will os.path.normpath and os.path.normcase all paths to help\n    assure this.  This can also handle the case where the given old\n    path variable is a list instead of a string, in which case a list\n    will be returned instead of a string.\n\n    Example:\n      Old Path: "/foo/bar:/foo"\n      New Path: "/biz/boom:/foo"\n      Result:   "/foo/bar:/biz/boom:/foo"\n\n    If delete_existing is 0, then adding a path that exists\n    will not move it to the end; it will stay where it is in the list.\n\n    If canonicalize is not None, it is applied to each element of \n    newpath before use.\n    '
    orig = oldpath
    is_list = 1
    paths = orig
    if ((not is_List(orig)) and (not is_Tuple(orig))):
        paths = paths.split(sep)
        is_list = 0
    if is_String(newpath):
        newpaths = newpath.split(sep)
    elif ((not is_List(newpath)) and (not is_Tuple(newpath))):
        newpaths = [newpath]
    else:
        newpaths = newpath
    if canonicalize:
        newpaths = list(map(canonicalize, newpaths))
    if (not delete_existing):
        result = []
        normpaths = []
        for path in paths:
            if (not path):
                continue
            result.append(path)
            normpaths.append(os.path.normpath(os.path.normcase(path)))
        for path in newpaths:
            if (not path):
                continue
            normpath = os.path.normpath(os.path.normcase(path))
            if (normpath not in normpaths):
                result.append(path)
                normpaths.append(normpath)
        paths = result
    else:
        newpaths = (paths + newpaths)
        newpaths.reverse()
        normpaths = []
        paths = []
        for path in newpaths:
            normpath = os.path.normpath(os.path.normcase(path))
            if (path and (not (normpath in normpaths))):
                paths.append(path)
                normpaths.append(normpath)
        paths.reverse()
    if is_list:
        return paths
    else:
        return sep.join(paths)
