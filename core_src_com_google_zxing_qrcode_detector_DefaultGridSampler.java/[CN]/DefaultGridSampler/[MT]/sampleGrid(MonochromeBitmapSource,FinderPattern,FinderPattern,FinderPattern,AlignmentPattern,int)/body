{
  float dimMinusThree=(float)dimension - 3.5f;
  float bottomRightX, bottomRightY;
  float sourceBottomRightX, sourceBottomRightY;
  if (alignmentPattern != null) {
    bottomRightX=alignmentPattern.getX();
    bottomRightY=alignmentPattern.getY();
    sourceBottomRightX=sourceBottomRightY=dimMinusThree - 3.0f;
  }
 else {
    bottomRightX=(topRight.getX() - topLeft.getX()) + bottomLeft.getX();
    bottomRightY=(topRight.getY() - topLeft.getY()) + bottomLeft.getY();
    sourceBottomRightX=sourceBottomRightY=dimMinusThree;
  }
  PerspectiveTransform transform=PerspectiveTransform.quadrilateralToQuadrilateral(3.5f,3.5f,dimMinusThree,3.5f,sourceBottomRightX,sourceBottomRightY,3.5f,dimMinusThree,topLeft.getX(),topLeft.getY(),topRight.getX(),topRight.getY(),bottomRightX,bottomRightY,bottomLeft.getX(),bottomLeft.getY());
  BitMatrix bits=new BitMatrix(dimension);
  float[] points=new float[dimension << 1];
  for (int i=0; i < dimension; i++) {
    int max=points.length;
    float iValue=(float)i + 0.5f;
    for (int j=0; j < max; j+=2) {
      points[j]=(float)(j >> 1) + 0.5f;
      points[j + 1]=iValue;
    }
    transform.transformPoints(points);
    checkEndpoint(image,points);
    for (int j=0; j < max; j+=2) {
      if (image.isBlack((int)points[j],(int)points[j + 1])) {
        bits.set(i,j >> 1);
      }
    }
  }
  return bits;
}
