def find_file(self, filename, paths, verbose=None):
    '\n        find_file(str, [Dir()]) -> [nodes]\n\n        filename - a filename to find\n        paths - a list of directory path *nodes* to search in.  Can be\n                represented as a list, a tuple, or a callable that is\n                called with no arguments and returns the list or tuple.\n\n        returns - the node created from the found file.\n\n        Find a node corresponding to either a derived file or a file\n        that exists already.\n\n        Only the first file found is returned, and none is returned\n        if no file is found.\n        '
    memo_key = self._find_file_key(filename, paths)
    try:
        memo_dict = self._memo['find_file']
    except KeyError:
        memo_dict = {}
        self._memo['find_file'] = memo_dict
    else:
        try:
            return memo_dict[memo_key]
        except KeyError:
            pass
    if (verbose and (not callable(verbose))):
        if (not SCons.Util.is_String(verbose)):
            verbose = 'find_file'
        _verbose = (u'  %s: ' % verbose)
        verbose = (lambda s: sys.stdout.write((_verbose + s)))
    (filedir, filename) = os.path.split(filename)
    if filedir:
        self.default_filedir = filedir
        paths = [_f for _f in map(self.filedir_lookup, paths) if _f]
    result = None
    for dir in paths:
        if verbose:
            verbose(("looking for '%s' in '%s' ...\n" % (filename, dir)))
        (node, d) = dir.srcdir_find_file(filename)
        if node:
            if verbose:
                verbose(("... FOUND '%s' in '%s'\n" % (filename, d)))
            result = node
            break
    memo_dict[memo_key] = result
    return result
