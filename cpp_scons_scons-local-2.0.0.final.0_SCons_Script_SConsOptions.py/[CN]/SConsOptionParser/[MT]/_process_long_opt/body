def _process_long_opt(self, rargs, values):
    '\n        SCons-specific processing of long options.\n\n        This is copied directly from the normal\n        optparse._process_long_opt() method, except that, if configured\n        to do so, we catch the exception thrown when an unknown option\n        is encountered and just stick it back on the "leftover" arguments\n        for later (re-)processing.\n        '
    arg = rargs.pop(0)
    if ('=' in arg):
        (opt, next_arg) = arg.split('=', 1)
        rargs.insert(0, next_arg)
        had_explicit_value = True
    else:
        opt = arg
        had_explicit_value = False
    try:
        opt = self._match_long_opt(opt)
    except optparse.BadOptionError:
        if self.preserve_unknown_options:
            self.largs.append(arg)
            if had_explicit_value:
                rargs.pop(0)
            return
        raise
    option = self._long_opt[opt]
    if option.takes_value():
        nargs = option.nargs
        if (nargs == '?'):
            if had_explicit_value:
                value = rargs.pop(0)
            else:
                value = option.const
        elif (len(rargs) < nargs):
            if (nargs == 1):
                self.error((_('%s option requires an argument') % opt))
            else:
                self.error((_('%s option requires %d arguments') % (opt, nargs)))
        elif (nargs == 1):
            value = rargs.pop(0)
        else:
            value = tuple(rargs[0:nargs])
            del rargs[0:nargs]
    elif had_explicit_value:
        self.error((_('%s option does not take a value') % opt))
    else:
        value = None
    option.process(opt, value, values, self)
