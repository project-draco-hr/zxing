{
  boolean upperShift=false;
  do {
    int oneByte=bits.readBits(8);
    if (oneByte == 0) {
      throw new ReaderException("0 is an invalid ASCII codeword");
    }
 else     if (oneByte <= 128) {
      oneByte=upperShift ? (oneByte + 128) : oneByte;
      upperShift=false;
      result.append((char)(oneByte - 1));
      return ASCII_ENCODE;
    }
 else     if (oneByte == 129) {
      return PAD_ENCODE;
    }
 else     if (oneByte <= 229) {
      int value=oneByte - 130;
      if (value < 10) {
        result.append('0');
      }
      result.append(value);
    }
 else     if (oneByte == 230) {
      return C40_ENCODE;
    }
 else     if (oneByte == 231) {
      return BASE256_ENCODE;
    }
 else     if (oneByte == 232) {
      throw new ReaderException("Currently not supporting FNC1");
    }
 else     if (oneByte == 233) {
      throw new ReaderException("Currently not supporting Structured Append");
    }
 else     if (oneByte == 234) {
      throw new ReaderException("Currently not supporting Reader Programming");
    }
 else     if (oneByte == 235) {
      upperShift=true;
    }
 else     if (oneByte == 236) {
      result.append("[)>\u001E05\u001D");
      resultTrailer.insert(0,"\u001E\u0004");
    }
 else     if (oneByte == 237) {
      result.append("[)>\u001E06\u001D");
      resultTrailer.insert(0,"\u001E\u0004");
    }
 else     if (oneByte == 238) {
      return ANSIX12_ENCODE;
    }
 else     if (oneByte == 239) {
      return TEXT_ENCODE;
    }
 else     if (oneByte == 240) {
      return EDIFACT_ENCODE;
    }
 else     if (oneByte == 241) {
      throw new ReaderException("Currently not supporting ECI Character");
    }
 else     if (oneByte >= 242) {
      throw new ReaderException(oneByte + " should not be used in ASCII encodation");
    }
  }
 while (bits.available() > 0);
  return ASCII_ENCODE;
}
