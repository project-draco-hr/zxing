{
  Version.ECBlocks ecBlocks=version.getECBlocksForLevel(ecLevel);
  int totalBlocks=0;
  Version.ECB[] ecBlockArray=ecBlocks.getECBlocks();
  for (int i=0; i < ecBlockArray.length; i++) {
    totalBlocks+=ecBlockArray[i].getCount();
  }
  DataBlock[] result=new DataBlock[totalBlocks];
  int numResultBlocks=0;
  for (int j=0; j < ecBlockArray.length; j++) {
    Version.ECB ecBlock=ecBlockArray[j];
    for (int i=0; i < ecBlock.getCount(); i++) {
      int numDataCodewords=ecBlock.getDataCodewords();
      int numBlockCodewords=ecBlocks.getECCodewords() + numDataCodewords;
      result[numResultBlocks++]=new DataBlock(numDataCodewords,new byte[numBlockCodewords]);
    }
  }
  int shorterBlocksTotalCodewords=result[0].codewords.length;
  int longerBlocksStartAt=result.length - 1;
  while (longerBlocksStartAt >= 0) {
    int numCodewords=result[longerBlocksStartAt].codewords.length;
    if (numCodewords == shorterBlocksTotalCodewords) {
      break;
    }
    if (numCodewords != shorterBlocksTotalCodewords + 1) {
      throw new IllegalStateException("Data block sizes differ by more than 1");
    }
    longerBlocksStartAt--;
  }
  longerBlocksStartAt++;
  int shorterBlocksNumDataCodewords=shorterBlocksTotalCodewords - ecBlocks.getECCodewords();
  int rawCodewordsOffset=0;
  for (int i=0; i < shorterBlocksNumDataCodewords; i++) {
    for (int j=0; j < numResultBlocks; j++) {
      result[j].codewords[i]=rawCodewords[rawCodewordsOffset++];
    }
  }
  for (int j=longerBlocksStartAt; j < numResultBlocks; j++) {
    result[j].codewords[shorterBlocksNumDataCodewords]=rawCodewords[rawCodewordsOffset++];
  }
  int max=result[0].codewords.length;
  for (int i=shorterBlocksNumDataCodewords; i < max; i++) {
    for (int j=0; j < numResultBlocks; j++) {
      int iOffset=j < longerBlocksStartAt ? i : i + 1;
      result[j].codewords[iOffset]=rawCodewords[rawCodewordsOffset++];
    }
  }
  if (rawCodewordsOffset != rawCodewords.length) {
    throw new IllegalStateException();
  }
  return result;
}
