{
  MonochromeBitmapSource image=this.image;
  if (!BlackPointEstimationMethod.TWO_D_SAMPLING.equals(image.getLastEstimationMethod())) {
    image.estimateBlackPoint(BlackPointEstimationMethod.TWO_D_SAMPLING,0);
  }
  FinderPatternFinder finder=new FinderPatternFinder(image);
  FinderPatternInfo info=finder.find();
  FinderPattern topLeft=info.getTopLeft();
  FinderPattern topRight=info.getTopRight();
  FinderPattern bottomLeft=info.getBottomLeft();
  float moduleSize=calculateModuleSize(topLeft,topRight,bottomLeft);
  int dimension=computeDimension(topLeft,topRight,bottomLeft,moduleSize);
  Version provisionalVersion=Version.getProvisionalVersionForDimension(dimension);
  int modulesBetweenFPCenters=provisionalVersion.getDimensionForVersion() - 7;
  AlignmentPattern alignmentPattern=null;
  if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
    float bottomRightX=topRight.getX() - topLeft.getX() + bottomLeft.getX();
    float bottomRightY=topRight.getY() - topLeft.getY() + bottomLeft.getY();
    float correctionToTopLeft=1.0f - 3.0f / (float)modulesBetweenFPCenters;
    int estAlignmentX=(int)(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
    int estAlignmentY=(int)(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));
    for (int i=4; i <= 16; i<<=1) {
      try {
        alignmentPattern=findAlignmentInRegion(moduleSize,estAlignmentX,estAlignmentY,(float)i);
        break;
      }
 catch (      ReaderException re) {
      }
    }
    if (alignmentPattern == null) {
      throw new ReaderException("Could not find alignment pattern");
    }
  }
  GridSampler sampler=GridSampler.getInstance();
  BitMatrix bits=sampler.sampleGrid(image,topLeft,topRight,bottomLeft,alignmentPattern,dimension);
  ResultPoint[] points;
  if (alignmentPattern == null) {
    points=new ResultPoint[]{bottomLeft,topLeft,topRight};
  }
 else {
    points=new ResultPoint[]{bottomLeft,topLeft,topRight,alignmentPattern};
  }
  return new DetectorResult(bits,points);
}
