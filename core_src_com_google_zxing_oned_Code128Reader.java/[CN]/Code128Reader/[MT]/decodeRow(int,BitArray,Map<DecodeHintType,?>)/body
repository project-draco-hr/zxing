{
  int[] startPatternInfo=findStartPattern(row);
  int startCode=startPatternInfo[2];
  int codeSet;
switch (startCode) {
case CODE_START_A:
    codeSet=CODE_CODE_A;
  break;
case CODE_START_B:
codeSet=CODE_CODE_B;
break;
case CODE_START_C:
codeSet=CODE_CODE_C;
break;
default :
throw FormatException.getFormatInstance();
}
boolean done=false;
boolean isNextShifted=false;
StringBuilder result=new StringBuilder(20);
List<Byte> rawCodes=new ArrayList<Byte>(20);
int lastStart=startPatternInfo[0];
int nextStart=startPatternInfo[1];
int[] counters=new int[6];
int lastCode=0;
int code=0;
int checksumTotal=startCode;
int multiplier=0;
boolean lastCharacterWasPrintable=true;
while (!done) {
boolean unshift=isNextShifted;
isNextShifted=false;
lastCode=code;
code=decodeCode(row,counters,nextStart);
rawCodes.add((byte)code);
if (code != CODE_STOP) {
lastCharacterWasPrintable=true;
}
if (code != CODE_STOP) {
multiplier++;
checksumTotal+=multiplier * code;
}
lastStart=nextStart;
for (int counter : counters) {
nextStart+=counter;
}
switch (code) {
case CODE_START_A:
case CODE_START_B:
case CODE_START_C:
throw FormatException.getFormatInstance();
}
switch (codeSet) {
case CODE_CODE_A:
if (code < 64) {
result.append((char)(' ' + code));
}
 else if (code < 96) {
result.append((char)(code - 64));
}
 else {
if (code != CODE_STOP) {
lastCharacterWasPrintable=false;
}
switch (code) {
case CODE_FNC_1:
case CODE_FNC_2:
case CODE_FNC_3:
case CODE_FNC_4_A:
break;
case CODE_SHIFT:
isNextShifted=true;
codeSet=CODE_CODE_B;
break;
case CODE_CODE_B:
codeSet=CODE_CODE_B;
break;
case CODE_CODE_C:
codeSet=CODE_CODE_C;
break;
case CODE_STOP:
done=true;
break;
}
}
break;
case CODE_CODE_B:
if (code < 96) {
result.append((char)(' ' + code));
}
 else {
if (code != CODE_STOP) {
lastCharacterWasPrintable=false;
}
switch (code) {
case CODE_FNC_1:
case CODE_FNC_2:
case CODE_FNC_3:
case CODE_FNC_4_B:
break;
case CODE_SHIFT:
isNextShifted=true;
codeSet=CODE_CODE_A;
break;
case CODE_CODE_A:
codeSet=CODE_CODE_A;
break;
case CODE_CODE_C:
codeSet=CODE_CODE_C;
break;
case CODE_STOP:
done=true;
break;
}
}
break;
case CODE_CODE_C:
if (code < 100) {
if (code < 10) {
result.append('0');
}
result.append(code);
}
 else {
if (code != CODE_STOP) {
lastCharacterWasPrintable=false;
}
switch (code) {
case CODE_FNC_1:
break;
case CODE_CODE_A:
codeSet=CODE_CODE_A;
break;
case CODE_CODE_B:
codeSet=CODE_CODE_B;
break;
case CODE_STOP:
done=true;
break;
}
}
break;
}
if (unshift) {
codeSet=codeSet == CODE_CODE_A ? CODE_CODE_B : CODE_CODE_A;
}
}
int width=row.getSize();
while (nextStart < width && row.get(nextStart)) {
nextStart++;
}
if (!row.isRange(nextStart,Math.min(width,nextStart + (nextStart - lastStart) / 2),false)) {
throw NotFoundException.getNotFoundInstance();
}
checksumTotal-=multiplier * lastCode;
if (checksumTotal % 103 != lastCode) {
throw ChecksumException.getChecksumInstance();
}
int resultLength=result.length();
if (resultLength > 0 && lastCharacterWasPrintable) {
if (codeSet == CODE_CODE_C) {
result.delete(resultLength - 2,resultLength);
}
 else {
result.delete(resultLength - 1,resultLength);
}
}
String resultString=result.toString();
if (resultString.length() < 2) {
throw FormatException.getFormatInstance();
}
float left=(float)(startPatternInfo[1] + startPatternInfo[0]) / 2.0f;
float right=(float)(nextStart + lastStart) / 2.0f;
int rawCodesSize=rawCodes.size();
byte[] rawBytes=new byte[rawCodesSize];
for (int i=0; i < rawCodesSize; i++) {
rawBytes[i]=rawCodes.get(i);
}
return new Result(resultString,rawBytes,new ResultPoint[]{new ResultPoint(left,(float)rowNumber),new ResultPoint(right,(float)rowNumber)},BarcodeFormat.CODE_128);
}
