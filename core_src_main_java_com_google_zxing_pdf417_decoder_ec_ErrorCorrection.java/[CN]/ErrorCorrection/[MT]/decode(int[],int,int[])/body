{
  ModulusPoly poly=new ModulusPoly(field,received);
  int[] S=new int[numECCodewords];
  boolean error=false;
  for (int i=numECCodewords; i > 0; i--) {
    int eval=poly.evaluateAt(field.exp(i));
    S[numECCodewords - i]=eval;
    if (eval != 0) {
      error=true;
    }
  }
  if (!error) {
    return 0;
  }
  ModulusPoly knownErrors=field.getOne();
  if (erasures != null) {
    for (    int erasure : erasures) {
      int b=field.exp(received.length - 1 - erasure);
      ModulusPoly term=new ModulusPoly(field,new int[]{field.subtract(0,b),1});
      knownErrors=knownErrors.multiply(term);
    }
  }
  ModulusPoly syndrome=new ModulusPoly(field,S);
  ModulusPoly[] sigmaOmega=runEuclideanAlgorithm(field.buildMonomial(numECCodewords,1),syndrome,numECCodewords);
  ModulusPoly sigma=sigmaOmega[0];
  ModulusPoly omega=sigmaOmega[1];
  int[] errorLocations=findErrorLocations(sigma);
  int[] errorMagnitudes=findErrorMagnitudes(omega,sigma,errorLocations);
  for (int i=0; i < errorLocations.length; i++) {
    int position=received.length - 1 - field.log(errorLocations[i]);
    if (position < 0) {
      throw ChecksumException.getChecksumInstance();
    }
    received[position]=field.subtract(received[position],errorMagnitudes[i]);
  }
  return errorLocations.length;
}
