{
  if (bits.sizeInBytes() != numDataBytes) {
    throw new WriterException("Number of bits and data bytes does not match");
  }
  int dataBytesOffset=0;
  int maxNumDataBytes=0;
  int maxNumEcBytes=0;
  Vector blocks=new Vector(numRSBlocks);
  for (int i=0; i < numRSBlocks; ++i) {
    int[] numDataBytesInBlock=new int[1];
    int[] numEcBytesInBlock=new int[1];
    getNumDataBytesAndNumECBytesForBlockID(numTotalBytes,numDataBytes,numRSBlocks,i,numDataBytesInBlock,numEcBytesInBlock);
    ByteArray dataBytes=new ByteArray();
    dataBytes.set(bits.getArray(),dataBytesOffset,numDataBytesInBlock[0]);
    ByteArray ecBytes=generateECBytes(dataBytes,numEcBytesInBlock[0]);
    blocks.addElement(new BlockPair(dataBytes,ecBytes));
    maxNumDataBytes=Math.max(maxNumDataBytes,dataBytes.size());
    maxNumEcBytes=Math.max(maxNumEcBytes,ecBytes.size());
    dataBytesOffset+=numDataBytesInBlock[0];
  }
  if (numDataBytes != dataBytesOffset) {
    throw new WriterException("Data bytes does not match offset");
  }
  for (int i=0; i < maxNumDataBytes; ++i) {
    for (int j=0; j < blocks.size(); ++j) {
      final ByteArray dataBytes=((BlockPair)blocks.elementAt(j)).getDataBytes();
      if (i < dataBytes.size()) {
        result.appendBits(dataBytes.at(i),8);
      }
    }
  }
  for (int i=0; i < maxNumEcBytes; ++i) {
    for (int j=0; j < blocks.size(); ++j) {
      final ByteArray ecBytes=((BlockPair)blocks.elementAt(j)).getErrorCorrectionBytes();
      if (i < ecBytes.size()) {
        result.appendBits(ecBytes.at(i),8);
      }
    }
  }
  if (numTotalBytes != result.sizeInBytes()) {
    throw new WriterException("Interleaving error: " + numTotalBytes + " and "+ result.sizeInBytes()+ " differ.");
  }
}
