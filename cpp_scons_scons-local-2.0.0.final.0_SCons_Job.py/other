'SCons.Job\n\nThis module defines the Serial and Parallel classes that execute tasks to\ncomplete a build. The Jobs class provides a higher level interface to start,\nstop, and wait on jobs.\n\n'
__revision__ = 'src/engine/SCons/Job.py 5023 2010/06/14 22:05:46 scons'
import SCons.compat
import os
import signal
import SCons.Errors
explicit_stack_size = None
default_stack_size = 256
interrupt_msg = 'Build interrupted.'
try:
    import queue
    import threading
except ImportError:
    pass
else:


    class Worker(threading.Thread):
        'A worker thread waits on a task to be posted to its request queue,\n        dequeues the task, executes it, and posts a tuple including the task\n        and a boolean indicating whether the task executed successfully. '

        def __init__(self, requestQueue, resultsQueue, interrupted):
            threading.Thread.__init__(self)
            self.setDaemon(1)
            self.requestQueue = requestQueue
            self.resultsQueue = resultsQueue
            self.interrupted = interrupted
            self.start()

        def run(self):
            while True:
                task = self.requestQueue.get()
                if (task is None):
                    break
                try:
                    if self.interrupted():
                        raise SCons.Errors.BuildError(task.targets[0], errstr=interrupt_msg)
                    task.execute()
                except:
                    task.exception_set()
                    ok = False
                else:
                    ok = True
                self.resultsQueue.put((task, ok))


    class ThreadPool(object):
        'This class is responsible for spawning and managing worker threads.'

        def __init__(self, num, stack_size, interrupted):
            "Create the request and reply queues, and 'num' worker threads.\n            \n            One must specify the stack size of the worker threads. The\n            stack size is specified in kilobytes.\n            "
            self.requestQueue = queue.Queue(0)
            self.resultsQueue = queue.Queue(0)
            try:
                prev_size = threading.stack_size((stack_size * 1024))
            except AttributeError as e:
                if (not (explicit_stack_size is None)):
                    msg = ('Setting stack size is unsupported by this version of Python:\n    ' + e.args[0])
                    SCons.Warnings.warn(SCons.Warnings.StackSizeWarning, msg)
            except ValueError as e:
                msg = ('Setting stack size failed:\n    ' + str(e))
                SCons.Warnings.warn(SCons.Warnings.StackSizeWarning, msg)
            self.workers = []
            for _ in range(num):
                worker = Worker(self.requestQueue, self.resultsQueue, interrupted)
                self.workers.append(worker)
            if ('prev_size' in locals()):
                threading.stack_size(prev_size)

        def put(self, task):
            'Put task into request queue.'
            self.requestQueue.put(task)

        def get(self):
            'Remove and return a result tuple from the results queue.'
            return self.resultsQueue.get()

        def preparation_failed(self, task):
            self.resultsQueue.put((task, False))

        def cleanup(self):
            '\n            Shuts down the thread pool, giving each worker thread a\n            chance to shut down gracefully.\n            '
            for _ in self.workers:
                self.requestQueue.put(None)
            for worker in self.workers:
                worker.join(1.0)
            self.workers = []


    class Parallel(object):
        'This class is used to execute tasks in parallel, and is somewhat \n        less efficient than Serial, but is appropriate for parallel builds.\n\n        This class is thread safe.\n        '

        def __init__(self, taskmaster, num, stack_size):
            "Create a new parallel job given a taskmaster.\n\n            The taskmaster's next_task() method should return the next\n            task that needs to be executed, or None if there are no more\n            tasks. The taskmaster's executed() method will be called\n            for each task when it is successfully executed or failed()\n            will be called if the task failed to execute (i.e. execute()\n            raised an exception).\n\n            Note: calls to taskmaster are serialized, but calls to\n            execute() on distinct tasks are not serialized, because\n            that is the whole point of parallel jobs: they can execute\n            multiple tasks simultaneously. "
            self.taskmaster = taskmaster
            self.interrupted = InterruptState()
            self.tp = ThreadPool(num, stack_size, self.interrupted)
            self.maxjobs = num

        def start(self):
            'Start the job. This will begin pulling tasks from the\n            taskmaster and executing them, and return when there are no\n            more tasks. If a task fails to execute (i.e. execute() raises\n            an exception), then the job will stop.'
            jobs = 0
            while True:
                while (jobs < self.maxjobs):
                    task = self.taskmaster.next_task()
                    if (task is None):
                        break
                    try:
                        task.prepare()
                    except:
                        task.exception_set()
                        task.failed()
                        task.postprocess()
                    else:
                        if task.needs_execute():
                            self.tp.put(task)
                            jobs = (jobs + 1)
                        else:
                            task.executed()
                            task.postprocess()
                if ((not task) and (not jobs)):
                    break
                while True:
                    (task, ok) = self.tp.get()
                    jobs = (jobs - 1)
                    if ok:
                        task.executed()
                    else:
                        if self.interrupted():
                            try:
                                raise SCons.Errors.BuildError(task.targets[0], errstr=interrupt_msg)
                            except:
                                task.exception_set()
                        task.failed()
                    task.postprocess()
                    if self.tp.resultsQueue.empty():
                        break
            self.tp.cleanup()
            self.taskmaster.cleanup()
