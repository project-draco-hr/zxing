{
  Point pina=pCenter;
  Point pinb=pCenter;
  Point pinc=pCenter;
  Point pind=pCenter;
  boolean color=true;
  for (nbCenterLayers=1; nbCenterLayers < 9; nbCenterLayers++) {
    Point pouta=getFirstDifferent(pina,color,1,-1);
    Point poutb=getFirstDifferent(pinb,color,1,1);
    Point poutc=getFirstDifferent(pinc,color,-1,1);
    Point poutd=getFirstDifferent(pind,color,-1,-1);
    if (nbCenterLayers > 2) {
      float q=distance(poutd,pouta) * nbCenterLayers / (distance(pind,pina) * (nbCenterLayers + 2));
      if (q < 0.75 || q > 1.25 || !isWhiteOrBlackRectangle(pouta,poutb,poutc,poutd)) {
        break;
      }
    }
    pina=pouta;
    pinb=poutb;
    pinc=poutc;
    pind=poutd;
    color=!color;
  }
  if (nbCenterLayers != 5 && nbCenterLayers != 7) {
    throw NotFoundException.getNotFoundInstance();
  }
  compact=nbCenterLayers == 5;
  float ratio=0.75f * 2 / (2 * nbCenterLayers - 3);
  int dx=pina.x - pinc.x;
  int dy=pina.y - pinc.y;
  int targetcx=MathUtils.round(pinc.x - ratio * dx);
  int targetcy=MathUtils.round(pinc.y - ratio * dy);
  int targetax=MathUtils.round(pina.x + ratio * dx);
  int targetay=MathUtils.round(pina.y + ratio * dy);
  dx=pinb.x - pind.x;
  dy=pinb.y - pind.y;
  int targetdx=MathUtils.round(pind.x - ratio * dx);
  int targetdy=MathUtils.round(pind.y - ratio * dy);
  int targetbx=MathUtils.round(pinb.x + ratio * dx);
  int targetby=MathUtils.round(pinb.y + ratio * dy);
  if (!isValid(targetax,targetay) || !isValid(targetbx,targetby) || !isValid(targetcx,targetcy)|| !isValid(targetdx,targetdy)) {
    throw NotFoundException.getNotFoundInstance();
  }
  return new Point[]{new Point(targetax,targetay),new Point(targetbx,targetby),new Point(targetcx,targetcy),new Point(targetdx,targetdy)};
}
