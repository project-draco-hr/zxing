{
  ResultPoint[] cornerPoints=rectangleDetector.detect();
  ResultPoint pointA=cornerPoints[0];
  ResultPoint pointB=cornerPoints[1];
  ResultPoint pointC=cornerPoints[2];
  ResultPoint pointD=cornerPoints[3];
  Vector transitions=new Vector(4);
  transitions.addElement(transitionsBetween(pointA,pointB));
  transitions.addElement(transitionsBetween(pointA,pointC));
  transitions.addElement(transitionsBetween(pointB,pointD));
  transitions.addElement(transitionsBetween(pointC,pointD));
  Collections.insertionSort(transitions,new ResultPointsAndTransitionsComparator());
  ResultPointsAndTransitions lSideOne=(ResultPointsAndTransitions)transitions.elementAt(0);
  ResultPointsAndTransitions lSideTwo=(ResultPointsAndTransitions)transitions.elementAt(1);
  if (lSideOne.transitions > MIN_GIVEUP_THRESHOLD || lSideTwo.transitions > MIN_GIVEUP_THRESHOLD) {
    throw NotFoundException.getNotFoundInstance();
  }
  Hashtable pointCount=new Hashtable();
  increment(pointCount,lSideOne.getFrom());
  increment(pointCount,lSideOne.getTo());
  increment(pointCount,lSideTwo.getFrom());
  increment(pointCount,lSideTwo.getTo());
  ResultPoint maybeTopLeft=null;
  ResultPoint bottomLeft=null;
  ResultPoint maybeBottomRight=null;
  Enumeration points=pointCount.keys();
  while (points.hasMoreElements()) {
    ResultPoint point=(ResultPoint)points.nextElement();
    Integer value=(Integer)pointCount.get(point);
    if (value.intValue() == 2) {
      bottomLeft=point;
    }
 else {
      if (maybeTopLeft == null) {
        maybeTopLeft=point;
      }
 else {
        maybeBottomRight=point;
      }
    }
  }
  if (maybeTopLeft == null || bottomLeft == null || maybeBottomRight == null) {
    throw NotFoundException.getNotFoundInstance();
  }
  ResultPoint[] corners={maybeTopLeft,bottomLeft,maybeBottomRight};
  ResultPoint.orderBestPatterns(corners);
  ResultPoint bottomRight=corners[0];
  bottomLeft=corners[1];
  ResultPoint topLeft=corners[2];
  ResultPoint topRight;
  if (!pointCount.containsKey(pointA)) {
    topRight=pointA;
  }
 else   if (!pointCount.containsKey(pointB)) {
    topRight=pointB;
  }
 else   if (!pointCount.containsKey(pointC)) {
    topRight=pointC;
  }
 else {
    topRight=pointD;
  }
  int dimension=Math.max(transitionsBetween(topLeft,topRight).getTransitions(),transitionsBetween(bottomRight,topRight).getTransitions());
  if ((dimension & 0x01) == 1) {
    dimension++;
  }
  dimension+=2;
  ResultPoint correctedTopRight=correctTopRight(bottomLeft,bottomRight,topLeft,topRight,dimension);
  int dimension2=Math.min(transitionsBetween(topLeft,correctedTopRight).getTransitions(),transitionsBetween(bottomRight,correctedTopRight).getTransitions());
  dimension2++;
  if ((dimension2 & 0x01) == 1) {
    dimension2++;
  }
  BitMatrix bits=sampleGrid(image,topLeft,bottomLeft,bottomRight,correctedTopRight,dimension2);
  return new DetectorResult(bits,new ResultPoint[]{topLeft,bottomLeft,bottomRight,correctedTopRight});
}
