{
  ResultPoint[] cornerPoints=rectangleDetector.detect();
  ResultPoint pointA=cornerPoints[0];
  ResultPoint pointB=cornerPoints[1];
  ResultPoint pointC=cornerPoints[2];
  ResultPoint pointD=cornerPoints[3];
  Vector transitions=new Vector(4);
  transitions.addElement(transitionsBetween(pointA,pointB));
  transitions.addElement(transitionsBetween(pointA,pointC));
  transitions.addElement(transitionsBetween(pointB,pointD));
  transitions.addElement(transitionsBetween(pointC,pointD));
  Collections.insertionSort(transitions,new ResultPointsAndTransitionsComparator());
  ResultPointsAndTransitions lSideOne=(ResultPointsAndTransitions)transitions.elementAt(0);
  ResultPointsAndTransitions lSideTwo=(ResultPointsAndTransitions)transitions.elementAt(1);
  Hashtable pointCount=new Hashtable();
  increment(pointCount,lSideOne.getFrom());
  increment(pointCount,lSideOne.getTo());
  increment(pointCount,lSideTwo.getFrom());
  increment(pointCount,lSideTwo.getTo());
  ResultPoint maybeTopLeft=null;
  ResultPoint bottomLeft=null;
  ResultPoint maybeBottomRight=null;
  Enumeration points=pointCount.keys();
  while (points.hasMoreElements()) {
    ResultPoint point=(ResultPoint)points.nextElement();
    Integer value=(Integer)pointCount.get(point);
    if (value.intValue() == 2) {
      bottomLeft=point;
    }
 else {
      if (maybeTopLeft == null) {
        maybeTopLeft=point;
      }
 else {
        maybeBottomRight=point;
      }
    }
  }
  if (maybeTopLeft == null || bottomLeft == null || maybeBottomRight == null) {
    throw ReaderException.getInstance();
  }
  ResultPoint[] corners={maybeTopLeft,bottomLeft,maybeBottomRight};
  GenericResultPoint.orderBestPatterns(corners);
  ResultPoint bottomRight=corners[0];
  bottomLeft=corners[1];
  ResultPoint topLeft=corners[2];
  ResultPoint topRight;
  if (!pointCount.containsKey(pointA)) {
    topRight=pointA;
  }
 else   if (!pointCount.containsKey(pointB)) {
    topRight=pointB;
  }
 else   if (!pointCount.containsKey(pointC)) {
    topRight=pointC;
  }
 else {
    topRight=pointD;
  }
  int dimension;
  if (GenericResultPoint.crossProductZ(bottomLeft,bottomRight,topRight) < GenericResultPoint.crossProductZ(topRight,topLeft,bottomLeft)) {
    dimension=transitionsBetween(topLeft,topRight).getTransitions();
  }
 else {
    dimension=transitionsBetween(bottomRight,topRight).getTransitions();
  }
  dimension+=2;
  BitMatrix bits=sampleGrid(image,topLeft,bottomLeft,bottomRight,dimension);
  return new DetectorResult(bits,new ResultPoint[]{pointA,pointB,pointC,pointD});
}
