{
  BitArray bits=new BitArray();
  int mode=TABLE_UPPER;
  int[] idx=new int[5];
  int[] idxnext=new int[5];
  for (int i=0; i < data.length; i++) {
    int c=data[i] & 0xFF;
    int next=i < data.length - 1 ? data[i + 1] & 0xFF : 0;
    int punctWord=0;
    if (c == '\r' && next == '\n') {
      punctWord=2;
    }
 else     if (c == '.' && next == ' ') {
      punctWord=3;
    }
 else     if (c == ',' && next == ' ') {
      punctWord=4;
    }
 else     if (c == ':' && next == ' ') {
      punctWord=5;
    }
    if (punctWord > 0) {
      if (mode == TABLE_PUNCT) {
        outputWord(bits,TABLE_PUNCT,punctWord);
        i++;
        continue;
      }
 else       if (SHIFT_TABLE[mode][TABLE_PUNCT] >= 0) {
        outputWord(bits,mode,SHIFT_TABLE[mode][TABLE_PUNCT]);
        outputWord(bits,TABLE_PUNCT,punctWord);
        i++;
        continue;
      }
 else       if (LATCH_TABLE[mode][TABLE_PUNCT] >= 0) {
        outputWord(bits,mode,LATCH_TABLE[mode][TABLE_PUNCT]);
        outputWord(bits,TABLE_PUNCT,punctWord);
        mode=TABLE_PUNCT;
        i++;
        continue;
      }
    }
    int firstMatch=-1;
    int shiftMode=-1;
    int latchMode=-1;
    int j;
    for (j=0; j < TABLE_BINARY; j++) {
      idx[j]=CHAR_MAP[j][c];
      if (idx[j] > 0 && firstMatch < 0) {
        firstMatch=j;
      }
      if (shiftMode < 0 && idx[j] > 0 && SHIFT_TABLE[mode][j] >= 0) {
        shiftMode=j;
      }
      idxnext[j]=CHAR_MAP[j][next];
      if (latchMode < 0 && idx[j] > 0 && (next == 0 || idxnext[j] > 0) && LATCH_TABLE[mode][j] >= 0) {
        latchMode=j;
      }
    }
    if (shiftMode < 0 && latchMode < 0) {
      for (j=0; j < TABLE_BINARY; j++) {
        if (idx[j] > 0 && LATCH_TABLE[mode][j] >= 0) {
          latchMode=j;
          break;
        }
      }
    }
    if (idx[mode] > 0) {
      outputWord(bits,mode,idx[mode]);
    }
 else {
      if (latchMode >= 0) {
        outputWord(bits,mode,LATCH_TABLE[mode][latchMode]);
        outputWord(bits,latchMode,idx[latchMode]);
        mode=latchMode;
      }
 else       if (shiftMode >= 0) {
        outputWord(bits,mode,SHIFT_TABLE[mode][shiftMode]);
        outputWord(bits,shiftMode,idx[shiftMode]);
      }
 else {
        if (firstMatch >= 0) {
          if (mode == TABLE_PUNCT) {
            outputWord(bits,TABLE_PUNCT,LATCH_TABLE[TABLE_PUNCT][TABLE_UPPER]);
            mode=TABLE_UPPER;
            i--;
            continue;
          }
 else           if (mode == TABLE_DIGIT) {
            outputWord(bits,TABLE_DIGIT,LATCH_TABLE[TABLE_DIGIT][TABLE_UPPER]);
            mode=TABLE_UPPER;
            i--;
            continue;
          }
        }
        int k;
        int lookahead;
        for (k=i + 1, lookahead=0; k < data.length; k++) {
          next=data[k] & 0xFF;
          boolean binary=true;
          for (j=0; j < TABLE_BINARY; j++) {
            if (CHAR_MAP[j][next] > 0) {
              binary=false;
              break;
            }
          }
          if (binary) {
            lookahead=0;
          }
 else {
            if (lookahead >= 1) {
              k-=lookahead;
              break;
            }
            lookahead++;
          }
        }
        k-=i;
switch (mode) {
case TABLE_UPPER:
case TABLE_LOWER:
case TABLE_MIXED:
          outputWord(bits,mode,SHIFT_TABLE[mode][TABLE_BINARY]);
        break;
case TABLE_DIGIT:
      outputWord(bits,mode,LATCH_TABLE[mode][TABLE_UPPER]);
    mode=TABLE_UPPER;
  outputWord(bits,mode,SHIFT_TABLE[mode][TABLE_BINARY]);
break;
case TABLE_PUNCT:
outputWord(bits,mode,LATCH_TABLE[mode][TABLE_UPPER]);
mode=TABLE_UPPER;
outputWord(bits,mode,SHIFT_TABLE[mode][TABLE_BINARY]);
break;
}
if (k >= 32 && k < 63) {
k=31;
}
if (k > 542) {
k=542;
}
if (k < 32) {
bits.appendBits(k,5);
}
 else {
bits.appendBits(k - 31,16);
}
for (; k > 0; k--, i++) {
bits.appendBits(data[i],8);
}
i--;
}
}
}
return bits;
}
