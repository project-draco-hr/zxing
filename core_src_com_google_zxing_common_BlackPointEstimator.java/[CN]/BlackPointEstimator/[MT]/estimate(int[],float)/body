{
  if (Float.isNaN(biasTowardsWhite) || biasTowardsWhite <= 0.0f) {
    throw new IllegalArgumentException("Illegal biasTowardsWhite: " + biasTowardsWhite);
  }
  int numBuckets=histogram.length;
  int firstPeak=0;
  int firstPeakSize=0;
  for (int i=0; i < numBuckets; i++) {
    if (histogram[i] > firstPeakSize) {
      firstPeak=i;
      firstPeakSize=histogram[i];
    }
  }
  int secondPeak=0;
  int secondPeakScore=0;
  for (int i=0; i < numBuckets; i++) {
    int distanceToBiggest=i - firstPeak;
    int score=histogram[i] * distanceToBiggest * distanceToBiggest;
    if (score > secondPeakScore) {
      secondPeak=i;
      secondPeakScore=score;
    }
  }
  if (firstPeak > secondPeak) {
    int temp=firstPeak;
    firstPeak=secondPeak;
    secondPeak=temp;
  }
  if (secondPeak - firstPeak <= histogram.length >> 4) {
    throw new ReaderException("Too little dynamic range in luminance");
  }
  int bestValley=secondPeak - 1;
  int bestValleyScore=-1;
  for (int i=secondPeak - 1; i > firstPeak; i--) {
    int fromFirst=(int)(biasTowardsWhite * (i - firstPeak));
    int score=fromFirst * fromFirst * (secondPeak - i)* (256 - histogram[i]);
    if (score > bestValleyScore) {
      bestValley=i;
      bestValleyScore=score;
    }
  }
  return bestValley;
}
