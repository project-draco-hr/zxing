def scons_subst(strSubst, env, mode=SUBST_RAW, target=None, source=None, gvars={}, lvars={}, conv=None):
    "Expand a string or list containing construction variable\n    substitutions.\n\n    This is the work-horse function for substitutions in file names\n    and the like.  The companion scons_subst_list() function (below)\n    handles separating command lines into lists of arguments, so see\n    that function if that's what you're looking for.\n    "
    if (isinstance(strSubst, str) and (strSubst.find('$') < 0)):
        return strSubst


    class StringSubber(object):
        'A class to construct the results of a scons_subst() call.\n\n        This binds a specific construction environment, mode, target and\n        source with two methods (substitute() and expand()) that handle\n        the expansion.\n        '

        def __init__(self, env, mode, conv, gvars):
            self.env = env
            self.mode = mode
            self.conv = conv
            self.gvars = gvars

        def expand(self, s, lvars):
            'Expand a single "token" as necessary, returning an\n            appropriate string containing the expansion.\n\n            This handles expanding different types of things (strings,\n            lists, callables) appropriately.  It calls the wrapper\n            substitute() method to re-expand things as necessary, so that\n            the results of expansions of side-by-side strings still get\n            re-evaluated separately, not smushed together.\n            '
            if is_String(s):
                try:
                    (s0, s1) = s[:2]
                except (IndexError, ValueError):
                    return s
                if (s0 != '$'):
                    return s
                if (s1 == '$'):
                    return '$'
                elif (s1 in '()'):
                    return s
                else:
                    key = s[1:]
                    if ((key[0] == '{') or (key.find('.') >= 0)):
                        if (key[0] == '{'):
                            key = key[1:(-1)]
                        try:
                            s = eval(key, self.gvars, lvars)
                        except KeyboardInterrupt:
                            raise
                        except Exception as e:
                            if (e.__class__ in AllowableExceptions):
                                return ''
                            raise_exception(e, lvars['TARGETS'], s)
                    elif (key in lvars):
                        s = lvars[key]
                    elif (key in self.gvars):
                        s = self.gvars[key]
                    elif (not (NameError in AllowableExceptions)):
                        raise_exception(NameError(key), lvars['TARGETS'], s)
                    else:
                        return ''
                    lv = lvars.copy()
                    var = key.split('.')[0]
                    lv[var] = ''
                    return self.substitute(s, lv)
            elif is_Sequence(s):

                def func(l, conv=self.conv, substitute=self.substitute, lvars=lvars):
                    return conv(substitute(l, lvars))
                return list(map(func, s))
            elif callable(s):
                try:
                    s = s(target=lvars['TARGETS'], source=lvars['SOURCES'], env=self.env, for_signature=(self.mode != SUBST_CMD))
                except TypeError:
                    if (self.mode == SUBST_RAW):
                        return s
                    s = self.conv(s)
                return self.substitute(s, lvars)
            elif (s is None):
                return ''
            else:
                return s

        def substitute(self, args, lvars):
            'Substitute expansions in an argument or list of arguments.\n\n            This serves as a wrapper for splitting up a string into\n            separate tokens.\n            '
            if (is_String(args) and (not isinstance(args, CmdStringHolder))):
                args = str(args)
                try:

                    def sub_match(match):
                        return self.conv(self.expand(match.group(1), lvars))
                    result = _dollar_exps.sub(sub_match, args)
                except TypeError:
                    args = _separate_args.findall(args)
                    result = []
                    for a in args:
                        result.append(self.conv(self.expand(a, lvars)))
                    if (len(result) == 1):
                        result = result[0]
                    else:
                        result = ''.join(map(str, result))
                return result
            else:
                return self.expand(args, lvars)
    if (conv is None):
        conv = _strconv[mode]
    if ('TARGET' not in lvars):
        d = subst_dict(target, source)
        if d:
            lvars = lvars.copy()
            lvars.update(d)
    gvars['__builtins__'] = __builtins__
    ss = StringSubber(env, mode, conv, gvars)
    result = ss.substitute(strSubst, lvars)
    try:
        del gvars['__builtins__']
    except KeyError:
        pass
    if is_String(result):
        remove = _regex_remove[mode]
        if remove:
            result = remove.sub('', result)
        if (mode != SUBST_RAW):
            result = _space_sep.sub(' ', result).strip()
    elif is_Sequence(result):
        remove = _list_remove[mode]
        if remove:
            result = remove(result)
    return result
