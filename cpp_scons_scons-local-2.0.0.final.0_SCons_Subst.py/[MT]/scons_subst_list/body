def scons_subst_list(strSubst, env, mode=SUBST_RAW, target=None, source=None, gvars={}, lvars={}, conv=None):
    "Substitute construction variables in a string (or list or other\n    object) and separate the arguments into a command list.\n\n    The companion scons_subst() function (above) handles basic\n    substitutions within strings, so see that function instead\n    if that's what you're looking for.\n    "


    class ListSubber(collections.UserList):
        'A class to construct the results of a scons_subst_list() call.\n\n        Like StringSubber, this class binds a specific construction\n        environment, mode, target and source with two methods\n        (substitute() and expand()) that handle the expansion.\n\n        In addition, however, this class is used to track the state of\n        the result(s) we\'re gathering so we can do the appropriate thing\n        whenever we have to append another word to the result--start a new\n        line, start a new word, append to the current word, etc.  We do\n        this by setting the "append" attribute to the right method so\n        that our wrapper methods only need ever call ListSubber.append(),\n        and the rest of the object takes care of doing the right thing\n        internally.\n        '

        def __init__(self, env, mode, conv, gvars):
            collections.UserList.__init__(self, [])
            self.env = env
            self.mode = mode
            self.conv = conv
            self.gvars = gvars
            if (self.mode == SUBST_RAW):
                self.add_strip = (lambda x: self.append(x))
            else:
                self.add_strip = (lambda x: None)
            self.in_strip = None
            self.next_line()

        def expand(self, s, lvars, within_list):
            'Expand a single "token" as necessary, appending the\n            expansion to the current result.\n\n            This handles expanding different types of things (strings,\n            lists, callables) appropriately.  It calls the wrapper\n            substitute() method to re-expand things as necessary, so that\n            the results of expansions of side-by-side strings still get\n            re-evaluated separately, not smushed together.\n            '
            if is_String(s):
                try:
                    (s0, s1) = s[:2]
                except (IndexError, ValueError):
                    self.append(s)
                    return
                if (s0 != '$'):
                    self.append(s)
                    return
                if (s1 == '$'):
                    self.append('$')
                elif (s1 == '('):
                    self.open_strip('$(')
                elif (s1 == ')'):
                    self.close_strip('$)')
                else:
                    key = s[1:]
                    if ((key[0] == '{') or (key.find('.') >= 0)):
                        if (key[0] == '{'):
                            key = key[1:(-1)]
                        try:
                            s = eval(key, self.gvars, lvars)
                        except KeyboardInterrupt:
                            raise
                        except Exception as e:
                            if (e.__class__ in AllowableExceptions):
                                return
                            raise_exception(e, lvars['TARGETS'], s)
                    elif (key in lvars):
                        s = lvars[key]
                    elif (key in self.gvars):
                        s = self.gvars[key]
                    elif (not (NameError in AllowableExceptions)):
                        raise_exception(NameError(), lvars['TARGETS'], s)
                    else:
                        return
                    lv = lvars.copy()
                    var = key.split('.')[0]
                    lv[var] = ''
                    self.substitute(s, lv, 0)
                    self.this_word()
            elif is_Sequence(s):
                for a in s:
                    self.substitute(a, lvars, 1)
                    self.next_word()
            elif callable(s):
                try:
                    s = s(target=lvars['TARGETS'], source=lvars['SOURCES'], env=self.env, for_signature=(self.mode != SUBST_CMD))
                except TypeError:
                    if (self.mode == SUBST_RAW):
                        self.append(s)
                        return
                    s = self.conv(s)
                self.substitute(s, lvars, within_list)
            elif (s is None):
                self.this_word()
            else:
                self.append(s)

        def substitute(self, args, lvars, within_list):
            'Substitute expansions in an argument or list of arguments.\n\n            This serves as a wrapper for splitting up a string into\n            separate tokens.\n            '
            if (is_String(args) and (not isinstance(args, CmdStringHolder))):
                args = str(args)
                args = _separate_args.findall(args)
                for a in args:
                    if (a[0] in ' \t\n\r\x0c\x0b'):
                        if ('\n' in a):
                            self.next_line()
                        elif within_list:
                            self.append(a)
                        else:
                            self.next_word()
                    else:
                        self.expand(a, lvars, within_list)
            else:
                self.expand(args, lvars, within_list)

        def next_line(self):
            'Arrange for the next word to start a new line.  This\n            is like starting a new word, except that we have to append\n            another line to the result.'
            collections.UserList.append(self, [])
            self.next_word()

        def this_word(self):
            'Arrange for the next word to append to the end of the\n            current last word in the result.'
            self.append = self.add_to_current_word

        def next_word(self):
            'Arrange for the next word to start a new word.'
            self.append = self.add_new_word

        def add_to_current_word(self, x):
            'Append the string x to the end of the current last word\n            in the result.  If that is not possible, then just add\n            it as a new word.  Make sure the entire concatenated string\n            inherits the object attributes of x (in particular, the\n            escape function) by wrapping it as CmdStringHolder.'
            if ((not self.in_strip) or (self.mode != SUBST_SIG)):
                try:
                    current_word = self[(-1)][(-1)]
                except IndexError:
                    self.add_new_word(x)
                else:
                    try:
                        last_char = str(current_word)[(-1)]
                    except IndexError:
                        last_char = '\x00'
                    if (last_char in '<>|'):
                        self.add_new_word(x)
                    else:
                        y = (current_word + x)
                        y = self.conv(y)
                        if is_String(y):
                            y = CmdStringHolder(y, None)
                        self[(-1)][(-1)] = y

        def add_new_word(self, x):
            if ((not self.in_strip) or (self.mode != SUBST_SIG)):
                literal = self.literal(x)
                x = self.conv(x)
                if is_String(x):
                    x = CmdStringHolder(x, literal)
                self[(-1)].append(x)
            self.append = self.add_to_current_word

        def literal(self, x):
            try:
                l = x.is_literal
            except AttributeError:
                return None
            else:
                return l()

        def open_strip(self, x):
            'Handle the "open strip" $( token.'
            self.add_strip(x)
            self.in_strip = 1

        def close_strip(self, x):
            'Handle the "close strip" $) token.'
            self.add_strip(x)
            self.in_strip = None
    if (conv is None):
        conv = _strconv[mode]
    if ('TARGET' not in lvars):
        d = subst_dict(target, source)
        if d:
            lvars = lvars.copy()
            lvars.update(d)
    gvars['__builtins__'] = __builtins__
    ls = ListSubber(env, mode, conv, gvars)
    ls.substitute(strSubst, lvars, 0)
    try:
        del gvars['__builtins__']
    except KeyError:
        pass
    return ls.data
