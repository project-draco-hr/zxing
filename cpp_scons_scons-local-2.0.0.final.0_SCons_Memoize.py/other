__revision__ = 'src/engine/SCons/Memoize.py 5023 2010/06/14 22:05:46 scons'
__doc__ = 'Memoizer\n\nA metaclass implementation to count hits and misses of the computed\nvalues that various methods cache in memory.\n\nUse of this modules assumes that wrapped methods be coded to cache their\nvalues in a consistent way.  Here is an example of wrapping a method\nthat returns a computed value, with no input parameters:\n\n    memoizer_counters = []                                      # Memoization\n\n    memoizer_counters.append(SCons.Memoize.CountValue(\'foo\'))   # Memoization\n\n    def foo(self):\n\n        try:                                                    # Memoization\n            return self._memo[\'foo\']                            # Memoization\n        except KeyError:                                        # Memoization\n            pass                                                # Memoization\n\n        result = self.compute_foo_value()\n\n        self._memo[\'foo\'] = result                              # Memoization\n\n        return result\n\nHere is an example of wrapping a method that will return different values\nbased on one or more input arguments:\n\n    def _bar_key(self, argument):                               # Memoization\n        return argument                                         # Memoization\n\n    memoizer_counters.append(SCons.Memoize.CountDict(\'bar\', _bar_key)) # Memoization\n\n    def bar(self, argument):\n\n        memo_key = argument                                     # Memoization\n        try:                                                    # Memoization\n            memo_dict = self._memo[\'bar\']                       # Memoization\n        except KeyError:                                        # Memoization\n            memo_dict = {}                                      # Memoization\n            self._memo[\'dict\'] = memo_dict                      # Memoization\n        else:                                                   # Memoization\n            try:                                                # Memoization\n                return memo_dict[memo_key]                      # Memoization\n            except KeyError:                                    # Memoization\n                pass                                            # Memoization\n\n        result = self.compute_bar_value(argument)\n\n        memo_dict[memo_key] = result                            # Memoization\n\n        return result\n\nAt one point we avoided replicating this sort of logic in all the methods\nby putting it right into this module, but we\'ve moved away from that at\npresent (see the "Historical Note," below.).\n\nDeciding what to cache is tricky, because different configurations\ncan have radically different performance tradeoffs, and because the\ntradeoffs involved are often so non-obvious.  Consequently, deciding\nwhether or not to cache a given method will likely be more of an art than\na science, but should still be based on available data from this module.\nHere are some VERY GENERAL guidelines about deciding whether or not to\ncache return values from a method that\'s being called a lot:\n\n    --  The first question to ask is, "Can we change the calling code\n        so this method isn\'t called so often?"  Sometimes this can be\n        done by changing the algorithm.  Sometimes the *caller* should\n        be memoized, not the method you\'re looking at.\n\n    --  The memoized function should be timed with multiple configurations\n        to make sure it doesn\'t inadvertently slow down some other\n        configuration.\n\n    --  When memoizing values based on a dictionary key composed of\n        input arguments, you don\'t need to use all of the arguments\n        if some of them don\'t affect the return values.\n\nHistorical Note:  The initial Memoizer implementation actually handled\nthe caching of values for the wrapped methods, based on a set of generic\nalgorithms for computing hashable values based on the method\'s arguments.\nThis collected caching logic nicely, but had two drawbacks:\n\n    Running arguments through a generic key-conversion mechanism is slower\n    (and less flexible) than just coding these things directly.  Since the\n    methods that need memoized values are generally performance-critical,\n    slowing them down in order to collect the logic isn\'t the right\n    tradeoff.\n\n    Use of the memoizer really obscured what was being called, because\n    all the memoized methods were wrapped with re-used generic methods.\n    This made it more difficult, for example, to use the Python profiler\n    to figure out how to optimize the underlying methods.\n'
import types
use_memoizer = None
CounterList = []
