def process_warn_strings(arguments):
    'Process string specifications of enabling/disabling warnings,\n    as passed to the --warn option or the SetOption(\'warn\') function.\n    \n\n    An argument to this option should be of the form <warning-class>\n    or no-<warning-class>.  The warning class is munged in order\n    to get an actual class name from the classes above, which we\n    need to pass to the {enable,disable}WarningClass() functions.\n    The supplied <warning-class> is split on hyphens, each element\n    is capitalized, then smushed back together.  Then the string\n    "Warning" is appended to get the class name.\n\n    For example, \'deprecated\' will enable the DeprecatedWarning\n    class.  \'no-dependency\' will disable the DependencyWarning class.\n\n    As a special case, --warn=all and --warn=no-all will enable or\n    disable (respectively) the base Warning class of all warnings.\n\n    '

    def _capitalize(s):
        if (s[:5] == 'scons'):
            return ('SCons' + s[5:])
        else:
            return s.capitalize()
    for arg in arguments:
        elems = arg.lower().split('-')
        enable = 1
        if (elems[0] == 'no'):
            enable = 0
            del elems[0]
        if ((len(elems) == 1) and (elems[0] == 'all')):
            class_name = 'Warning'
        else:
            class_name = (''.join(map(_capitalize, elems)) + 'Warning')
        try:
            clazz = globals()[class_name]
        except KeyError:
            sys.stderr.write(("No warning type: '%s'\n" % arg))
        else:
            if enable:
                enableWarningClass(clazz)
            elif issubclass(clazz, MandatoryDeprecatedWarning):
                fmt = "Can not disable mandataory warning: '%s'\n"
                sys.stderr.write((fmt % arg))
            else:
                suppressWarningClass(clazz)
