def _find_next_ready_node(self):
    '\n        Finds the next node that is ready to be built.\n\n        This is *the* main guts of the DAG walk.  We loop through the\n        list of candidates, looking for something that has no un-built\n        children (i.e., that is a leaf Node or has dependencies that are\n        all leaf Nodes or up-to-date).  Candidate Nodes are re-scanned\n        (both the target Node itself and its sources, which are always\n        scanned in the context of a given target) to discover implicit\n        dependencies.  A Node that must wait for some children to be\n        built will be put back on the candidates list after the children\n        have finished building.  A Node that has been put back on the\n        candidates list in this way may have itself (or its sources)\n        re-scanned, in order to handle generated header files (e.g.) and\n        the implicit dependencies therein.\n\n        Note that this method does not do any signature calculation or\n        up-to-date check itself.  All of that is handled by the Task\n        class.  This is purely concerned with the dependency graph walk.\n        '
    self.ready_exc = None
    T = self.trace
    if T:
        T.write((u'\n' + self.trace_message('Looking for a node to evaluate')))
    while True:
        node = self.next_candidate()
        if (node is None):
            if T:
                T.write((self.trace_message('No candidate anymore.') + u'\n'))
            return None
        node = node.disambiguate()
        state = node.get_state()
        if CollectStats:
            if (not hasattr(node, 'stats')):
                node.stats = Stats()
                StatsNodes.append(node)
            S = node.stats
            S.considered = (S.considered + 1)
        else:
            S = None
        if T:
            T.write(self.trace_message((u'    Considering node %s and its children:' % self.trace_node(node))))
        if (state == NODE_NO_STATE):
            node.set_state(NODE_PENDING)
        elif (state > NODE_PENDING):
            if S:
                S.already_handled = (S.already_handled + 1)
            if T:
                T.write(self.trace_message(u'       already handled (executed)'))
            continue
        executor = node.get_executor()
        try:
            children = executor.get_all_children()
        except SystemExit:
            exc_value = sys.exc_info()[1]
            e = SCons.Errors.ExplicitExit(node, exc_value.code)
            self.ready_exc = (SCons.Errors.ExplicitExit, e)
            if T:
                T.write(self.trace_message('       SystemExit'))
            return node
        except Exception as e:
            self.ready_exc = sys.exc_info()
            if S:
                S.problem = (S.problem + 1)
            if T:
                T.write(self.trace_message(('       exception %s while scanning children.\n' % e)))
            return node
        children_not_visited = []
        children_pending = set()
        children_not_ready = []
        children_failed = False
        for child in chain(executor.get_all_prerequisites(), children):
            childstate = child.get_state()
            if T:
                T.write(self.trace_message((u'       ' + self.trace_node(child))))
            if (childstate == NODE_NO_STATE):
                children_not_visited.append(child)
            elif (childstate == NODE_PENDING):
                children_pending.add(child)
            elif (childstate == NODE_FAILED):
                children_failed = True
            if (childstate <= NODE_EXECUTING):
                children_not_ready.append(child)
        children_not_visited.reverse()
        self.candidates.extend(self.order(children_not_visited))
        if children_failed:
            for n in executor.get_action_targets():
                n.set_state(NODE_FAILED)
            if S:
                S.child_failed = (S.child_failed + 1)
            if T:
                T.write(self.trace_message(('****** %s\n' % self.trace_node(node))))
            continue
        if children_not_ready:
            for child in children_not_ready:
                if S:
                    S.not_built = (S.not_built + 1)
                node.ref_count = (node.ref_count + child.add_to_waiting_parents(node))
                if T:
                    T.write(self.trace_message((u'     adjusted ref count: %s, child %s' % (self.trace_node(node), repr(str(child))))))
            if T:
                for pc in children_pending:
                    T.write(self.trace_message(('       adding %s to the pending children set\n' % self.trace_node(pc))))
            self.pending_children = (self.pending_children | children_pending)
            continue
        wait_side_effects = False
        for se in executor.get_action_side_effects():
            if (se.get_state() == NODE_EXECUTING):
                se.add_to_waiting_s_e(node)
                wait_side_effects = True
        if wait_side_effects:
            if S:
                S.side_effects = (S.side_effects + 1)
            continue
        if S:
            S.build = (S.build + 1)
        if T:
            T.write(self.trace_message((u'Evaluating %s\n' % self.trace_node(node))))
        return node
    return None
