def _validate_pending_children(self):
    '\n        Validate the content of the pending_children set. Assert if an\n        internal error is found.\n\n        This function is used strictly for debugging the taskmaster by\n        checking that no invariants are violated. It is not used in\n        normal operation.\n\n        The pending_children set is used to detect cycles in the\n        dependency graph. We call a "pending child" a child that is\n        found in the "pending" state when checking the dependencies of\n        its parent node.\n\n        A pending child can occur when the Taskmaster completes a loop\n        through a cycle. For example, lets imagine a graph made of\n        three node (A, B and C) making a cycle. The evaluation starts\n        at node A. The taskmaster first consider whether node A\'s\n        child B is up-to-date. Then, recursively, node B needs to\n        check whether node C is up-to-date. This leaves us with a\n        dependency graph looking like:\n\n                                      Next candidate                                                               Node A (Pending) --> Node B(Pending) --> Node C (NoState)\n                ^                                     |\n                |                                     |\n                +-------------------------------------+\n\n        Now, when the Taskmaster examines the Node C\'s child Node A,\n        it finds that Node A is in the "pending" state. Therefore,\n        Node A is a pending child of node C.\n\n        Pending children indicate that the Taskmaster has potentially\n        loop back through a cycle. We say potentially because it could\n        also occur when a DAG is evaluated in parallel. For example,\n        consider the following graph:\n\n\n        Node A (Pending) --> Node B(Pending) --> Node C (Pending) --> ...\n                |                                     ^\n                |                                     |\n                +----------> Node D (NoState) --------+\n                                  /\n                  Next candidate /\n\n        The Taskmaster first evaluates the nodes A, B, and C and\n        starts building some children of node C. Assuming, that the\n        maximum parallel level has not been reached, the Taskmaster\n        will examine Node D. It will find that Node C is a pending\n        child of Node D.\n\n        In summary, evaluating a graph with a cycle will always\n        involve a pending child at one point. A pending child might\n        indicate either a cycle or a diamond-shaped DAG. Only a\n        fraction of the nodes ends-up being a "pending child" of\n        another node. This keeps the pending_children set small in\n        practice.\n\n        We can differentiate between the two cases if we wait until\n        the end of the build. At this point, all the pending children\n        nodes due to a diamond-shaped DAG will have been properly\n        built (or will have failed to build). But, the pending\n        children involved in a cycle will still be in the pending\n        state.\n\n        The taskmaster removes nodes from the pending_children set as\n        soon as a pending_children node moves out of the pending\n        state. This also helps to keep the pending_children set small.\n        '
    for n in self.pending_children:
        assert (n.state in (NODE_PENDING, NODE_EXECUTING)), (str(n), StateString[n.state])
        assert (len(n.waiting_parents) != 0), (str(n), len(n.waiting_parents))
        for p in n.waiting_parents:
            assert (p.ref_count > 0), (str(n), str(p), p.ref_count)
